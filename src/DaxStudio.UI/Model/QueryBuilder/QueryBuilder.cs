using ADOTabular;
using DaxStudio.UI.Enums;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using DaxStudio.UI.Extensions;
using System.Data.SqlClient;
using DaxStudio.Interfaces.Enums;

namespace DaxStudio.UI.Model
{
    public static class QueryBuilder
    {
        static char DELIMITER = ',';
        const string NEWLINE = "\n";
        const string INDENT = "    ";

        public static string BuildQuery(ADOTabular.Interfaces.IModelCapabilities modelCaps, ICollection<QueryBuilderColumn> columns, ICollection<QueryBuilderFilter> filters, bool autoGenerated, string firstTableName, DelimiterType delimiterType)
        {
            DELIMITER = delimiterType == DelimiterType.SemiColon? ';' : ',' ;
            var measureDefines = BuildMeasureDefines(columns, firstTableName);

            // using filter variables will not work against older data sources...
            //var filterDefines = BuildFilterDefines(filters);
            var columnFilters = filters.Where(f => f.TabularObject.ObjectType == ADOTabularObjectType.Column);
            var measureFilters = filters.Where(f => f.TabularObject.ObjectType == ADOTabularObjectType.Measure);
            var columnList = BuildColumns(columns);
            var columnFilterList = BuildFilters(modelCaps, columnFilters,autoGenerated, false);
            var measureFilterList = BuildFilters(modelCaps, measureFilters, autoGenerated, true);
            var measureList = BuildMeasures(columns);
            var orderByList = BuildOrderBy(columns);
            
            var measureStart = !string.IsNullOrWhiteSpace(measureList)
                ? columns.Any(c => c.ObjectType == ADOTabularObjectType.Column 
                                || c.ObjectType == ADOTabularObjectType.Level 
                                || c.ObjectType == ADOTabularObjectType.Hierarchy 
                                || c.ObjectType == ADOTabularObjectType.UnnaturalHierarchy)
                ? DELIMITER + NEWLINE + INDENT 
                : NEWLINE + INDENT
                : string.Empty;  


            if (columnList.Length == 0) return BuildQueryWithOnlyMeasures(measureDefines,columnFilterList, measureList,  measureStart, orderByList);
            return BuildQueryWithColumns(measureDefines, columnList, columnFilterList, measureFilterList, measureList, measureStart, orderByList);
        }

        private static string BuildOrderBy(ICollection<QueryBuilderColumn> orderBy)
        {
            // get all levels or columns
            var cols = orderBy.Where(c => (c.ObjectType == ADOTabularObjectType.Column || c.ObjectType == ADOTabularObjectType.Level) && c.SortDirection != SortDirection.None);
            if (!cols.Any()) return string.Empty;

            // build a comma separated list of [DaxName] values
            return "\nORDER BY " + NEWLINE + cols.Select(c => $"    {c.DaxName} {c.SortDirection}" ).Aggregate((current, next) => current + DELIMITER + NEWLINE + next);
        }

        private static string BuildQueryWithColumns(string measureDefines, string columnList, string columnFilters,string measureFilters, string measureList, string measureStart, string orderBy)
        {
            var columnFilterStart = columnFilters.Length > 0 ? DELIMITER + NEWLINE + INDENT : string.Empty;

            StringBuilder sbQuery = new StringBuilder();
            sbQuery.Append("/* START QUERY BUILDER */");
            sbQuery.Append(NEWLINE);
            sbQuery.Append(measureDefines.Length > 0 ? "DEFINE\n" : string.Empty);
            sbQuery.Append(measureDefines);
            sbQuery.Append(measureDefines.Length > 0 ? NEWLINE : string.Empty);
            sbQuery.Append("EVALUATE\n");
            if (!string.IsNullOrEmpty(measureFilters)) sbQuery.Append("FILTER(\n");
            sbQuery.Append("SUMMARIZECOLUMNS("); // table function start
            sbQuery.Append(NEWLINE);
            sbQuery.Append(INDENT);
            sbQuery.Append(columnList);
            sbQuery.Append(columnFilterStart);
            sbQuery.Append(columnFilters);
            sbQuery.Append(measureStart);
            sbQuery.Append(measureList);
            sbQuery.Append("\n)");
            if (!string.IsNullOrEmpty(measureFilters))
            {
                sbQuery.Append(NEWLINE);
                sbQuery.Append(DELIMITER);
                sbQuery.Append(measureFilters);
                sbQuery.Append(NEWLINE);
                sbQuery.Append(")");
            }
            sbQuery.Append(orderBy);
            // query function end
            sbQuery.Append("\n/* END QUERY BUILDER */");
            return sbQuery.ToString();
        }

        private static string BuildQueryWithOnlyMeasures(string measureDefines, string filterList, string measureList, string measureStart, string orderBy)
        {
            var filterStart = filterList.Length > 0 ? ",\n    " : string.Empty;

            StringBuilder sbQuery = new StringBuilder();
            sbQuery.Append("/* START QUERY BUILDER */\n");
            sbQuery.Append(measureDefines.Length > 0 ? "DEFINE\n" : string.Empty);
            sbQuery.Append(measureDefines);
            sbQuery.Append(measureDefines.Length > 0 ? "\n" : string.Empty);
            sbQuery.Append("EVALUATE\n");
            sbQuery.Append("CALCULATETABLE(\n    ");  // table function start
            sbQuery.Append("ROW(");                   // ROW function start
            sbQuery.Append(measureStart);
            sbQuery.Append(measureList);
            sbQuery.Append("\n    )");                // end of ROW() function
            sbQuery.Append(filterStart);
            sbQuery.Append(filterList);

            sbQuery.Append("\n)");                    // query function end
            sbQuery.Append(orderBy);
            sbQuery.Append("\n/* END QUERY BUILDER */");
            return sbQuery.ToString();
        }

        private static string BuildMeasures(ICollection<QueryBuilderColumn> columns)
        {
            
            var meas = columns.Where(c => c.IsMeasure());
            if (!meas.Any()) return string.Empty;
            // build a comma separated list of "Caption", [DaxName] values
            return meas.Select(c => $"\"{c.Caption}\"{DELIMITER} {c.DaxName}").Aggregate((i, j) => i +  DELIMITER + NEWLINE + INDENT + j);
        }

        private static string BuildMeasureDefines(ICollection<QueryBuilderColumn> columns, string firstTableName)
        {
            // TODO - should I get KPIs also??
            var meas = columns.Where(c => c.ObjectType == ADOTabularObjectType.Measure && c.IsOverriden);
            if (!meas.Any()) return string.Empty;
            
            // if the table name is missing from the measure "column"
            // try and fix this by grabbing the first non-null table name from any
            // other column in the query or by using the firstTableName passed in from the current connection
            var tableName = (columns.FirstOrDefault(c => !string.IsNullOrEmpty(c.TableName))?.DaxName) ?? firstTableName ?? string.Empty;
            
            return meas.Select(c => $"MEASURE {c?.SelectedTable?.DaxName??tableName}[{c.Caption}] = {c.MeasureExpression}" ).Aggregate((current, next) => current + "\n" + next);
        }

        private static string BuildColumns(ICollection<QueryBuilderColumn> columns)
        {
            var sbCols = new StringBuilder();
            // get all levels or columns
            foreach (var c in columns)
            {
                switch (c.ObjectType)
                {
                    case ADOTabularObjectType.Column:
                    case ADOTabularObjectType.Level:
                        sbCols.Append(c.DaxName);
                        sbCols.Append(DELIMITER);
                        sbCols.Append(NEWLINE);
                        sbCols.Append(INDENT);
                        break;
                    case ADOTabularObjectType.Hierarchy:
                    case ADOTabularObjectType.UnnaturalHierarchy:
                        var h = c.TabularObject as ADOTabularHierarchy;
                        sbCols.Append("// ");
                        sbCols.Append(h.Name);
                        sbCols.Append(" hierarchy\n");
                        sbCols.Append(INDENT);
                        foreach ( var l in h.Levels)
                        {
                            sbCols.Append(l.DaxName);
                            sbCols.Append(DELIMITER);
                            sbCols.Append(NEWLINE);
                            sbCols.Append(INDENT);
                        }
                        break;
                }
            }

            //var cols = columns.Where(c => c.ObjectType == ADOTabularObjectType.Column || c.ObjectType == ADOTabularObjectType.Level);
            //var hier = columns.Where(c => c.ObjectType == ADOTabularObjectType.Hierarchy || c.ObjectType == ADOTabularObjectType.UnnaturalHierarchy);

            //if (!cols.Any()) return string.Empty;

            //// build a comma separated list of [DaxName] values
            //return cols.Select(c => c.DaxName).Aggregate((current, next) => current + ",\n    " + next);
            if(sbCols.Length > 6) sbCols.Remove(sbCols.Length - 6, 6);

            return sbCols.ToString();
        }

        private static string BuildFilters(ADOTabular.Interfaces.IModelCapabilities modelCaps, IEnumerable<QueryBuilderFilter> filters, bool autoGenerated, bool predicatesOnly)
        {
            //DEFINE VAR __DS0FilterTable =
            //FILTER(
            //  KEEPFILTERS(VALUES('DimCustomer'[EnglishEducation])),
            //  'DimCustomer'[EnglishEducation] = "Bachelors"
            //)

            Func<QueryBuilderFilter,bool,bool,string> filterExpressionFunc = FilterExpressionBasic;
            if (modelCaps.DAXFunctions.TreatAs) filterExpressionFunc = FilterExpressionTreatAs;

            // if there are no filters return an empty string
            if (!filters.Any()) return string.Empty;
            // if we are returning predicatesOnly then join them with the && operator
            if (predicatesOnly) return (string)filters.Select(f => filterExpressionFunc(f, autoGenerated, predicatesOnly)).Aggregate((i, j) => i + "\n&& " + j);
            // else join the predicates with an indent and newline
            return (string)filters.Select(f => filterExpressionFunc(f,autoGenerated,predicatesOnly)).Aggregate((i, j) => i + DELIMITER + NEWLINE + INDENT + j);
        }

        public static string FilterExpressionTreatAs(QueryBuilderFilter filter,bool autoGenerated, bool predicatesOnly)
        {
            // if this is a measure filter then use the basic generator as TreatAs is not supported against measures
            if (filter.TabularObject.ObjectType == ADOTabularObjectType.Measure) return FilterExpressionBasic(filter, autoGenerated, predicatesOnly);

            var prefix = string.Empty;
            var formattedVal = FormattedValue(filter, () => filter.FilterValue, ()=> filter.FilterValueIsParameter ,autoGenerated, ref prefix);
            var colName = filter.TabularObject.DaxName;
            switch (filter.FilterType)
            {
                case FilterType.In:
                    return $@"{prefix}KEEPFILTERS( TREATAS( {{{formattedVal}}}{DELIMITER} {colName} ))";
                case FilterType.Is:
                    return $@"{prefix}KEEPFILTERS( TREATAS( {{{formattedVal}}}{DELIMITER} {colName} ))";
                default:
                    return FilterExpressionBasic(filter, autoGenerated, predicatesOnly);
            }
        }

        public static string FilterExpressionBasic(QueryBuilderFilter filter,bool autoGenerated, bool predicatesOnly)
        {
            var prefix = string.Empty;
            var colName = filter.TabularObject.DaxName;
            var formattedVal = FormattedValue(filter, () => filter.FilterValue, ()=> filter.FilterValueIsParameter ,autoGenerated, ref prefix);

            var filterStart = $@"{prefix}KEEPFILTERS( FILTER( ALL( {colName} ){DELIMITER} ";
            var filterEnd = "))";
            var predicate = string.Empty;

            
            switch (filter.FilterType)
            {
                case FilterType.Is:
                    predicate =$"{colName} = {formattedVal} ";
                    break;
                case FilterType.IsNot:
                    predicate = $"{colName} <> {formattedVal} ";
                    break;
                case FilterType.StartsWith:
                    predicate = $@"SEARCH( {formattedVal}, {colName}{DELIMITER} 1{DELIMITER} 0 ) = 1 ";
                    break;
                case FilterType.Contains:
                    predicate = $@"SEARCH( {formattedVal}, {colName}{DELIMITER} 1{DELIMITER} 0 ) >= 1 ";
                    break;
                case FilterType.DoesNotStartWith:
                    predicate = $@"NOT( SEARCH( {formattedVal}, {colName}{DELIMITER} 1{DELIMITER} 0 ) = 1 )";
                    break;
                case FilterType.DoesNotContain:
                    predicate = $@"NOT( SEARCH( {formattedVal}, {colName}{DELIMITER} 1{DELIMITER} 0 ) >= 1 )";
                    break;
                case FilterType.IsBlank:
                    predicate = $@"ISBLANK( {colName} )";
                    break;
                case FilterType.IsNotBlank:
                    predicate = $@"NOT( ISBLANK( {colName} ))";
                    break;
                case FilterType.GreaterThan:
                    predicate = $@"{colName} > {formattedVal} ";
                    break;
                case FilterType.GreaterThanOrEqual:
                    predicate = $@"{colName} >= {formattedVal} ";
                    break;
                case FilterType.LessThan:
                    predicate = $@"{colName} < {formattedVal} ";
                    break;
                case FilterType.LessThanOrEqual:
                    predicate = $@"{colName} <= {formattedVal} ";
                    break;
                case FilterType.Between:
                    var formattedVal2 = FormattedValue(filter, () => filter.FilterValue2, ()=> filter.FilterValue2IsParameter ,autoGenerated, ref prefix);
                    predicate = $@"{colName} >= {formattedVal} && {colName} <= {formattedVal2} ";
                    break;
                case FilterType.NotIn:
                    predicate = $@"NOT( {colName} IN {{{formattedVal}}} )";
                    break;
                case FilterType.In:
                    predicate = $@"{colName} IN {{{formattedVal}}} ";
                    break;
                default:
                    throw new NotSupportedException($"The filter type '{filter.FilterType}' is not supported");
            }
            
            if (predicatesOnly) return predicate.TrimEnd();

            return filterStart + predicate + filterEnd;
        }

        public static string FormattedValue(QueryBuilderFilter filter, Func<string> valueFunc, Func<bool> isParameter , bool autoGenerated, ref string prefix)
        {
            var isParam = isParameter();
            var val = valueFunc();

            if (isParam) return $"@{val}";

            if (filter.FilterType == FilterType.In || filter.FilterType == FilterType.NotIn)
            {
                // strip out \r and break on \n
                string[] valArray = val.Replace("\r","").Split('\n');
                return valArray.Aggregate("", (prev, current) => { return prev + DELIMITER + FormatValueInternal(filter.TabularObject.SystemType, current); }).TrimStart(DELIMITER);
            }
            try
            {
                return FormatValueInternal(filter.TabularObject.SystemType, val);
            }
            catch (Exception ex)
            {
                if (autoGenerated) prefix = $"-- ERROR creating filter: {ex.Message}\n" + INDENT;
                else throw;
            }
            return string.Empty;
        }

        private static string FormatValueInternal(Type dataType, string val)
        {
            if (dataType == typeof(DateTime))
            {
                DateTime.TryParse(val, out var parsedDate);
                if (parsedDate > DateTime.MinValue)
                {
                    return $"DATE({parsedDate.Year},{parsedDate.Month},{parsedDate.Day})";
                }
                else
                {
                    throw new ArgumentException($"Unable to parse the value '{val}' as a DateTime value");
                }
            }
            if (dataType == null || dataType == typeof(Object))
            {
                if (long.TryParse(val, out var parsedLong)) dataType = typeof(long);
                if (decimal.TryParse(val, out var parsedDecimal)) dataType = typeof(decimal);
                dataType = typeof(string);
            }

            var quotes = dataType == typeof(string) ? "\"" : string.Empty;
            if (dataType == typeof(string) && val != null) val = val?.Replace("\"", "\"\""); // escape any quote characters in the filter string
            return $"{quotes}{val}{quotes}";
        }

    }
}
